[00:00] Agora que estamos com tudo pronto, “com a faca e o queijo na mão”, vimos que quando eu coloco as datas, a quantidade, o valor e clico em incluir eu tenho acesso aos elementos do dom. Sabemos que todo input tem a propriedade .value, que eu tenho acesso ao valor desse input, eu tenho os insumos para criar a minha negociação. Vamos voltar para lá.

[00:27] Vou voltar para o meu código, eu não vou fazer mais isso daqui porque vou ter uma const negociao = new Negociacao. Presta atenção, cuidado. O Visual Studio, de novo, me deu a opção de importar diretamente aqui em cima do meu código de negociação. Eu vou fazer isso: const negociao = new Negociacao();, fiz.

[01:04] Ele não importou, mas se eu clicar no azul, aparece “negociação importar”, eu posso fazer isso. Ele vai automaticamente importar para você não ter que digitar o caminho, mas você não pode esquecer de colocar o js no final senão não vai funcionar.

[01:31] Agora eu vou passar os valores que a minha negociação está esperando. O primeiro é a data, ( this.inputData.value, this;inputQuantidade.value, this.inputValor.value); } e por fim tenho uma negociação criada Não há nenhum erro de compilação, parece que meu código vai funcionar em runtime.

[02:01] Agora vou fazer um console.log(negociacao);. Vou salvar, vou esperar compilar. Tudo bonito, tudo maravilhoso. Verifique se você colocou o js aqui. Vou voltar para o navegador, vou dar um clear aqui, tirar esse “preserve log” e dar um clear. Vou colocar qualquer data, quantidade e valor, vou clicar em incluir e vemos nossa negociação que foi criada.

[02:31] Felicidade? Não. Não é felicidade nenhuma é tristeza porque se você olhar essa negociação, primeiro, a data tinha que ser um date e não essa string. Segundo, a quantidade está como string, o valor está como string. Isso faz parte da definição da nossa classe, eu espero que a quantidade seja um número, espero que o valor seja um número, espero que a data seja uma data.

[02:59] Se eu quiser fazer alguma operação matemática para somar a quantidade, o valor de uma negociação com a outra eu vou ter um bug porque duas strings somadas viram concatenação, não vai funcionar conforme o esperado.

[03:13] O que aconteceu? Por que o TypeScript não está brilhando aqui? Não está brilhando porque o nome já diz: TypeScript, faltou dizermos quais são os tipos dessas propriedades da minha negociação para que o TypeScript me diga que não posso colocar string porque não fará sentido.

[03:34] É isso que vamos entender no próximo vídeo, como é que “tipamos” a nossa classe negociação utilizando o recurso da tipagem estática do TypeScript para evitar que na hora que eu esteja escrevendo esse código ele me avise que vai dar problema. Como eu faço isso? Vamos lá ver.

/////////////////////////////////////////////////////////////////////////////////////////

[00:00] O que aconteceu? Não estamos usando a linguagem TypeScript. Deixa eu explicar. Eu vou lá para negociação, vou passar o mouse por cima de data, qual é o tipo que o Visual Studio Code está inferindo a partir do compilador TypeScript?

[00:19] Any, quantidade, valor, any. Você sabe que any em inglês é qualquer coisa, isso significa que a minha negociação, o construtor da minha negociação está aceitando qualquer coisa que você passar. Se você passar um abacaxi como data esse abacaxi vai entrar. Eu não tenho checagem nenhuma.

[00:47] O TypeScript adota o tipo any implicitamente. Isso é legal porque você consegue escrever um código rápido que você não precisa pensar muito, mas isso causa problemas no seu código como acabamos de ver. O que vamos fazer? A primeira coisa antes de tiparmos esse construtor, dizer que data tem que ser sempre date, quantidade tem que ser sempre número e valor tem que ser sempre número.

[01:10] Eu vou alterar uma configuração no compilador que eu sugiro quando você está começando um projeto do zero, você ativar. É que é para dizer para o TypeScript para ele não adotar o tipo any implicitamente, só se você por algum motivo do seu código você quiser que aquele campo seja any, por algum motivo de compatibilidade, ou seja o que for.

[01:34] Como fazemos isso? Vamos lá no meu "tsconfig", estou dentro do meu “tsconfig” tenho uma propriedade logo aqui que é "noImplicityAny" e eu vou colocar aqui true. Se segurem na cadeira porque quando eu ativar isso, o nosso programa vai parar de funcionar. Salvei. Já começou a ter erro de compilação em vários lugares. Vamos começar por partes.

[02:07] Vou lá para o meu "negociacao.ts" e vamos ver o que precisamos resolver. Já está mostrando aquele ponto que deu problema no construtor. O parâmetro data tem um tipo implícito any, eu tenho que dizer qual é o tipo correto. Qual é o tipo correto? Eu quero que seja date. Qual é o tipo da quantidade? Aí você sempre faz assim: quantidade: number. Qual é o tipo valor? valor: number. constructor(data: Date, quantidade: number, valor: number).

[02:35] Se você vem de linguagens como Java o tipo vem antes, aqui em TypeScript vem depois. Estou dizendo que na data só vai entrar date, quantidade number, valor number. E como esses valores aqui estão recebendo no construtor o TypeScript consegue inferir porque se você recebeu um date e aqui é o momento que você está atribuindo o valor a data ele consegue entender, se eu passo o mouse, que o valor é do tipo number, quantidade e date.

[03:11] Para ficar claro garanta, coloque o tipo aqui também: private _data: Date; private _quantidade: Number; private _valor: Number;. Quem está olhando a definição da sua classe vai ver number, o que não pode é que se aqui é number e aqui é string não vai encaixar, por isso você faz isso. E temos como simplificar isso, mas ainda não é a hora de lidar com simplificação é a hora de entendermos os fundamentos.

[03:37] Tipei o negociação, salvei. Ainda tem três erros que estão acontecendo lá no meu negociacao-controller. Vou lá em negociacao-controller. Faz sentido esse erro que estamos vendo? Faz, porque estou declarando uma propriedade da classe e não estou dizendo qual é o tipo.

[04:00] Inclusive, o TypeScript está te dizendo para evitar usar input. Como resolvemos isso? Vamos resolver agora o problema do negociacao-controller em um vídeo separado porque tem bastante coisa para vermos.

/////////////////////////////////////////////////////////////////////////////////////////

[00:00] Vamos fazer essa conversão. A primeira coisa que eu tenho que converter é essa string que representa uma data um objeto do tipo date. Vou fazer: const date = new Date();. Se eu faço isso ele vai criar uma data na data de hoje, eu não quero isso eu quero que ele crie uma data respeitando o que o usuário digitou.

[00:23] Para fazer isso precisamos passar uma string, por exemplo, nesse formato: ano, mês e dia separados por vírgula. O construtor de date entende e cria uma data bonita representando essa data. Porém, quando estamos lendo do teclado, do value, do meu campo, da data, ele vem com hífen.

[00:47] O que eu preciso fazer? Eu preciso substituir todos os hifens por vírgula e então passar a string para o date. Para fazer isso vou criar uma expressão regular, sabemos que toda expressão regular é feita com “barra barra”, “//”. O que vou dizer?

[01:05] Encontra tudo que é hífen, mas não quero que você encontre só o primeiro não eu quero que você encontre todos, o primeiro, o segundo, o terceiro, o quarto, todas as ocorrências eu coloco um g de global. const exp = /-/g;

[01:15] Olha que bacana, se eu passo o mouse aqui em cima, de novo, como estou atribuindo essa variável pela primeira vez o TypeScript entende que essa é uma expressão regular. Se é uma expressão regular eu consigo chamar os métodos exp.test da expressão regular e por aí vai.

[01:38] Criei a expressão regular e agora vou dizer que o date vai ganhar o valor de this.inputData.value., como value é uma string ele também me mostrou todos os métodos relacionados da string e vou usar o replace.

[01:54] O replace pode receber como parâmetro a primeira expressão regular e segundo o que você quer colocar no lugar quando a expressão regular encontrar o que você está procurando. Eu vou pedir para substituir com vírgula. cont date = new Date(this.inputData.value.replace(exp, ',')); No construtor estou passando o resultado de replace e vai procurar todo mundo que tem hífen e vai substituir por vírgula e criar o meu date.

[02:22] Segunda linha, eu vou ter a quantidade que conseguimos converter para inteiro através de parseInt(this.inputQuantidade.value);. E const valor eu vou usar o parseFloat porque esse valor pode ter decimais, vai ser const valor = parseFloat(this.inputValor.value);.

[02:51] Agora que eu tenho todos os valores convertidos eu vou trocar aqui para o meu construtor, vou apagar aqui, vou passar. const negociacao = new Negociacao(date, quantidade, valor);.

[03:08] Se eu pego agora aqui e coloco o date por último, const negociacao = new Negociacao(quantidade, valor, date);, vai ter erro de compilação porque estou tentando passar um number para o primeiro parâmetro do meu construtor que é um date. O TypeScript também te ajuda nisso.

[03:20] O meu código está compilando, vou salvar. Nenhum erro. Volto para o navegador. Vou lá e coloco: 1/11/1111, coloco a quantidade 2 e o valor 111, clico em "incluir". Está lá perfeito, a minha data com o objeto data aqui representado, a quantidade numérica e o valor numérico.

[03:46] Vou colocar aqui uma 12 para vermos aqui. Fiz 12 aqui, coloquei o decimal. Está convertido, está tudo bonito, temos certeza que a nossa negociação tem os tipos que estamos esperando, mas podemos melhorar mais um pouco. É isso que vamos ver no próximo vídeo, é só questão de organização. Vamos ver no próximo vídeo como organizamos isso aqui melhor.

Marque a opção correta que cria um objeto Date a partir de uma string:

Alternativa correta
const date = new Date('2021,2,20');

Alternativa correta! A string passada pelo construtor deve ter o ano, mês e dia separados por vírgula.

/////////////////////////////////////////////////////////////////////////////////////////

[00:00] Se você está lendo o método adiciona, o que você quer ler? Se você começar a ler esse método você vai ver expressão regular, pegou date, pegou quantidade, converteu valor para no final criar uma negociação. Se o adiciona a ideia é criarmos uma negociação, podemos deixar o nosso código um pouco mais claro.

[00:19] Para isso vou criar um método criaNegociacao();. Esse método criaNegociacao eu vou mover esse código que cria a negociação para dentro dele. E agora que eu movi para dentro dele vou dar return Negociacao, se eu passo em cima sobre o nome do método vemos que o método retorna uma negociação do tipo negociação e agora vou fazer o seguinte: const negociacao = this.criaNegociacao();

[01:09] Fica mais claro eu isolando isso. Vou salvar. Volto para o navegador, vou criar a minha negociação, clico em "incluir" e está lá bonito, gerou a minha negociação.

[01:28] Agora uma coisa que estamos falando aqui para organizar melhor o nosso código é o seguinte, vimos que é uma boa ideia tipar variáveis, trabalharmos com tipos, mas também podemos colocar tipos em retorno de métodos. Se eu passar o mouse em cima do adiciona, você vai ver que o adiciona o TypeScript está dizendo que o tipo de retorno desse método é void porque ele não retorna nada.

[01:56] Se eu passo o mouse aqui em cima do criarNegociacao, qual o tipo de retorno? O JavaScript é inteligente o suficiente para entender que como você está retornando uma negociação, ele entende que o tipo de retorno do criarNegociacao é uma negociação.

[02:13] Tanto é verdade que se eu disser que negociação é uma string vou ter um erro de compilação porque o string eu não posso atribuir uma negociação no tipo string, porque estou forçando o tipo string aqui.

[02:28] É uma boa prática. Eu sugiro que não peguemos carona nessa inferência do TypeScript, vamos tipar os retornos, os métodos. Já que adiciona não retorna nada, vamos colocar void. Se criarNegociacao retorna negociacao, deixa isso mais claro.

[02:56] Porque tem uma pegadinha, quando você está criando o método, olha o que eu poderia ter feito, eu poderia ter tirado o retorno daqui, eu poderia ter escrito o método ao invés de retornar a negociação, eu podia retornar um valor.

[03:12] O que esse método está retornando agora? Number. É porque eu errei, não era para retornar valor era para retornar negociação. Se você já começa tipando o seu método quando você retornar algo que antes de você implementar o método você acabou de implementar algo que não condiz com o tipo do retorno, você já ver um erro. O que eu fiz? Não é valor é negociação, vou retornar a negociação.

[03:43] Eu sugiro vocês fazerem isso. Vai começar a escrever o método a primeira coisa eu sei que quando eu terminar de executar esse método ou ele não vai retornar nada, ou ele vai retornar uma negociação, você já coloca o tipo. E olha que legal, o tipo está aqui e eu não dei retorno nenhum, o TypeScript está falando que não retornei nada e se não retorno nada tenho que retornar um valor ou coloco criarNegociacao como void, já que void não retorna nada.

[04:11] Você está blindado antes de escrever o seu método de que você tem certeza que você não vai comer uma gafe e que você sempre vai retornar uma negociação como retorno. E se eu omitir o retorno de novo o TypeScript vai me dizer que eu esperava retornar uma negociação, mas não retornou. Vamos usar isso daqui, vou tipar todos os métodos da nossa aplicação. Negociação, void, constructor não tipamos.

[04:43] Vou voltar para a negociação. Meu get implicitamente está retornando um date, mas vou colocar explicitamente que retorna Date, que quantidade retorna number, que valor retorna number e que o volume retorna number. Se eu tivesse cometido um erro aqui, o TypeScript iria me indicar. Vamos fazer isso, evitar o tipo any. Você só usa o tipo Any se realmente for preciso, tipa as propriedades de classe e os métodos que recebem os constructor.

[05:25] Se for uma variável que você está criando você pode deixar uma variável dentro de um método, você pode deixar que o TypeScript infira esse tipo de variável para você. Parâmetro de método, parâmetro de constructor, retorno de método e propriedades de classe vai lá e coloca o tipo que você está esperando.

[05:42] Mesmo que você queira usar any você vai lá e diz que você quer usar any. Fica essa dica. Vou salvar e tudo continua funcionando, está uma beleza. Vamos para o próximo assunto.

///////////////////////////////////////////////////////////////////////////////////////

[00:00] Antes de irmos para o próximo capítulo, vamos fazer uma melhoria na nossa aplicação. O que está acontecendo? Eu vou lá no meu formulário, eu digito uma data, digito uma quantidade, digito um valor, clico em "incluir". Em teoria eu teria que incluir em uma tabela, fazer alguma coisa, mas estamos exibindo no console.

[00:20] O esperado é que se você acabou de incluir, vamos limpar o formulário e colocar o focus diretamente no campo da data para que o usuário já possa sair digitando e cadastrando uma nova negociação. Como vamos fazer isso? É JavaScript puro, mas o TypeScript nos ajuda a lembrar muita coisa sem precisarmos ir lá consultar a documentação do JavaScript e por aí vai.

[00:47] Eu vou criar um método limparFormulario(), esse método vai ser void, não vai fazer nada. Qual é a ideia? Ele não está pronto ainda, mas eu sei que após exibir a minha negociação, assim que eu criei uma negociação, exibe em uma tabela ou exibe no console.log eu quero limpar formulário. this.LimparFormulario();

[01:23] Esse método vai ter que chegar aqui, pegar cada input começando pelo data, this.inputData.value = ' ' e vou limpar, vou passar uma string em branco. Vou chegar no segundo this.inputQuantidade.value = ' '; e vou passar uma string em branco.

[01:43] Olha só o TypeScript me ajudando, esqueci de colocar value e ele está dizendo que string não pode ser atribuído para html input element. Vou colocar agora this.inputValor.value - ' '; também vai ser uma string em branco.

[02:00] Eu sei que após limpar todos esses métodos o inputData eu quero colocar o focus. Para fazer o focus no elemento do dom você coloca .f e como o TypeScript sabe que focus é um elemento do dom já te mostra o método focus, this.inputData.focus();

[02:22] Toda vez que eu adicionar uma negociação eu vou primeiro exibir no console, depois eu limpo e vai ser isso. Vou salvar, meu método é void, por isso não retorna nada, vou salvar. Vou voltar para o navegador, deu refresh, vou digitar aqui, vou clicar em "incluir". Cliquei, exibiu, limpou meu formulário e já colocou o foco no data. Muito melhor que a experiência do usuário.

[02:57] O que eu queria ressaltar aqui é que como esse input data, o input valor são elementos do dom o TypeSript sabe, porque você tipou com html input element, ele sabe que inputData é um elemento dom por isso te dá um monte de opções, até querySelector. Ele vai te dar todos os métodos e propriedades desse elemento do dom.

[03:21] Está chegando a hora de puxarmos um pouco mais no curso e vamos lá, vamos continuar. Vamos para uma revisão no próximo vídeo.

/////////////////////////////////////////////////////////////////////////////////////////


REVISÃO !!!

[00:00] Agora vou fazer uma revisão. A primeira coisa que vimos é que na nossa “negociação controller” quando definimos propriedades de uma classe, se não colocamos o tipo essa classe ganha implícito any. Ou seja, o TypeScript não sabe no momento da declaração dessa propriedade da sua classe qual é o tipo dessa propriedade, ele adota o tipo any.

[00:29] O problema do tipo any é que você pode passar qualquer valor para dentro desse tipo que a aplicação vai continuar aceitando, você volta a ter mais ou menos o mesmo comportamento do JavaScript padrão.

[00:42] Porque o JavaScript padrão não faz a crítica de tipos. O que vimos é que a boa prática é você em propriedades de uma classe você definir um tipo da propriedade da classe, definir tipos também não só da propriedade da classe, mas também parâmetros de métodos.

[01:03] Se o meu constructor da minha classe recebe parâmetros, é uma boa prática eu explicitar o tipo. Vai deixar claro que se o desenvolvedor tentar passar algum tipo diferente daquele esperado eu vou ter um erro em tempo de compilação.

[01:18] Vimos também a ideia de ativar no nosso compilador, se voltarmos lá no centro nervoso do TypeScript, o "tsconfig.json", a boa prática de começarmos um projeto do zero é colocar "noImplicitAny": true. Isso significa que o TypeSript vai te forçar a colocar any ou colocar um tipo da sua escolha na declaração de propriedades de classe e por aí vai.

[01:47] Vimos também que o TypeScript eu não preciso, nesse caso, na hora que estou criando uma instância de negociação eu não preciso colocar o tipo porque quando a variável está existindo no momento e eu faço uma atribuição, o TypeScript consegue inferir o tipo.

[02:02] Diferente do meu controller porque aqui eu não tenho nenhuma atribuição inicial para esse método. O TypeScript não tem como, se eu fizer isso daqui, deixar assim, o TypeScript não sabe qual é esse valor porque a atribuição está sendo feita no constructor.

[02:23] Se eu chegar aqui e fazer ‘nome’, em string, eu não precisaria colocar o tipo string aqui, porque como estou atribuindo valor nesse momento que a minha instância de classe é criada, ele infere que esse método é do tipo string. Fazer isso daqui é perda de tempo, você pode fazer também, mas só se você sentir necessidade de colocar isso porque a ideia do TypeScript é você ter tipagem estática e tentar escrever um pouco menos.

[03:00] No caso do html input eu não tenho aqui como saber qual é o valor inicial dessa propriedade, por isso que eu tive que colocar o tipo porque a atribuição não está sendo feita através do constructor. Vimos também que métodos é interessante colocarmos o tipo de retorno do método, se você vem em linguagens como Java normalmente o tipo é antes, é na declaração do nome do método.

[03:33] Vimos que quando um método não retorna nada colocamos void e por aí vai. Resumindo as boas práticas: começou um projeto do zero noImplicitAny, vai declarar propriedades de uma classe, define o tipo logo. Se você não sabe o tipo ou se você ainda quer utilizar o any nada te impede de você chegar lá e explicitar o tipo any.

[03:55] Mas você sabe que ao utilizar o tipo any eu perco todo auto complete, toda a checagem do TypeScript porque se esse método é qualquer coisa o TypeScript não consegue inferir, porém se esse método for um html input element agora a coisa muda de sentido, eu tenho o typecheckin, eu posso verificar tudo o que eu posso fazer com essa propriedade.

[04:20] Por fim, limpamos o nosso código, isolamos o código que cria a negociação do próprio método, o código que limpa o formulário é o próprio para que o método adicione esse método que temos, mais fácil de ler. Vamos para o próximo capítulo, lá a coisa começa a ficar um pouco mais puxada, mas como esse curso é o curso de fundamentos vou pegar leve com vocês. Vamos lá.