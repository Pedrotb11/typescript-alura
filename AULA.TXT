CARREGAMENTO DE MODULOS

[00:00] Vamos abrir o projeto de novo para revisarmos. "Open" ou "Open Folder" > "Desktop > typescript-curso1", consigo ver a pasta do meu projeto, vou abrir o terminal, "New Terminal", vou executar meu comando npm run server que agora vai automaticamente abrir meu navegador. Se por acaso não abriu no seu você digita localhost 3000 temos que enviar nossa página aqui de negociação.

[00:34] Antes de cairmos dentro da parte de negociação quero fazer aqui uma introdução rápida com vocês. Caso vocês não tenham feito outro curso na Alura sobre sistema nativo módulo ECMAScript 6, como esse funciona porque vamos usar aqui ao longo do treinamento. É bem relâmpago e bem light.

[00:51] Vamos voltar para a nossa pasta. A primeira coisa que eu quero que vocês entendam é o seguinte, quando trabalhamos com sistema de módulos nativos do navegador, vamos importar um único módulo que é um script de JavaScript, um único módulo em Index html e é o navegador que vai ler esse módulo e vai descobrir o que ele necessita para funcionar e vai baixar para nós automaticamente outros módulos.

[01:19] Removendo a responsabilidade de ter que colocar vários scripts da nossa página e ter que lembrar a ordem de dependência entre eles. Isso é muito interessante. Podemos fazer isso nativamente no navegador.

[01:34] Como vamos fazer isso? Vamos lá dentro da pasts "js", dentro dela, clicamos em js/models ele vai estar com a seta para baixo, eu vou clicar com o botão direito, "New File", eu vou criar o App app.js. Cuidado na hora de criar porque ele não pode ficar dentro da pasta models, tenha a certeza que ele é filho direto da pasta js.

[01:57] Criei este humilde módulo porque não vamos falar script, porque trabalhando no sistema de módulos todo arquivo .js chamamos de módulo. Vou colocar aqui aquele humilde alert que aprendemos no curso de lógica de programação, coloquei o alert, vou voltar para o Index html e vou fazer isso uma única vez. Vou colocar aqui a tag <script type="module" src=>, para dizer que não é um script é um módulo.

[02:28] Onde está esta função? É só lembrarmos que a pasta "dist" é compartilhada na raiz do meu navegador quando eu abro o localhost 3000. Tenho que colocar a subpasta <script type="module" src="js/app.js"></script>. Vou fechar a tag script, vou salvar.

[02:49] Salvei, vou voltar ao navegador e automaticamente ele já recarregou e já me mostrou o alerta provando que a função está sendo carregada pelo sistema de módulos do ECMAScript. Então importei o módulo principal da aplicação e é dentro dele que toda a aplicação vai ser inicializada e por aí vai. Agora que entendemos isso vamos partir para a modelagem da nossa negociação que é o que interessa.

FINALIZAÇÃO DA AULA 1


[00:00] Vimos que é possível, no mundo JavaScript, com a linguagem mais moderna do JavaScript, criar atributos privados de uma classe, e nela eu posso atribuir valores através do construtor ou através de métodos “acessadores”.

[00:18] Vimos que é possível alterar quantidade, mas não é aquela quantidade privada da minha instância de negociação, é que o JavaScript como é uma linguagem dinâmica adicionou a propriedade quantidade dinamicamente nesse objeto, ele não tem relação nenhuma com a quantidade que está internamente na classe.

[00:39] Isso pode te confundir um pouco. Vamos ver se depois temos alguma coisa melhor para que isso não aconteça, mas o mais importante é entendermos aqui que a quantidade que está encapsulada em negociação ainda não é modificada, não está sendo modificada.

[00:55] Para terminar vou criar getters, somente leitura para quem quiser ler a data, a quantidade e o valor individualmente. Porque se eu fizer agora assim, chegar agora e colocar negociacao.data, se eu salvo e volto no meu navegador vai dar undefined, por a data ser privada, eu não tenho acesso a ela. Preciso criar alguém que me retorne essa data. Nem se eu fizer isso: negociacao.#data, vai dar erro de sintaxe.

[01:32] Como eu crio um getter? Eu vou chegar na minha classe de JavaScript, vou criar get data() {}, essa função vai me retornar return this.#data;. Eu vou criar get quantidade() {} que vai me retornar return this.#quantidade; }. Porque o get, assim como o método tem a acesso, sabe acessar os atributos privados da minha classe. Então get valor() {} e vou retornar return this.#valor;.

[02:11] Fiz isso, vou salvar. Volto em "App", quando eu crio o get eu consigo acessar a propriedade como se o get fosse uma propriedade classe, como se não fosse o método. O get é como se fosse o método, mas ele me dá um acesso como se fosse uma propriedade de classe. Fazendo isso agora tem que ser capaz. Salvei, vou voltar no navegador, recarregar.

[02:38] Eu consigo ver, ler a data. Está legal, eu consigo criar uma negociação, essa negociação se eu tenho de mudar as propriedades privadas dela eu não consigo, eu não criei nenhum método na minha classe que me permita fazer essa alteração.

[02:55] Contudo eu consigo a ler a data, eu consigo ler a quantidade e se eu tentar fazer isso aqui também não vai rolar. Se eu tentar fazer negociacao.data = Flavio;, quando executo o meu código, não dá, porque é get, eu não posso atribuir nada a um get, só ler.

[03:20] Está faltando o nosso volume. O volume vou criar como get: get volume(] { return this.#quantidade * this.#valor; }. Quantidade vezes valor. Salvei, vou voltar em App, eu quero imprimir o volume, como é um get eu acesso como se fosse uma propriedade ele tem que imprimir para mim 1000.

[03:55] Salvei, volto para o navegador, crio meu console, dou refresh e está lá 1000. Será que conseguimos materializar tudo bonito? É isso que vou mostrar para vocês no próximo vídeo. A coisa não está 100% e vamos ver que não é por nossa culpa, é por uma questão da limitação da linguagem JavaScript.

REVISAO DA AULA 2


[00:00] Vamos fazer uma revisão. Nós vimos que precisamos baixar o compilador TypeScript através do node do “npn”, após instalado não é suficiente só baixá-lo, precisamos criar o arquivo "tsconfig.json", o arquivo centro nervoso do compilador. Toda vez que você executar esse compilador, ele vai ler esse arquivo para saber o que ele tem que fazer.

[00:22] Em se tratando o que ele tem que fazer, o que precisamos dizer para o compilador? Precisamos dizer que onde estar a pasta com os arquivos TypeScript que ele vai ter que compilar, todos os nossos arquivos TypeScript ficaram dentro da pasta "app", se você escrever algum arquivo "ts" fora de "app", você não está seguindo o fluxo do treinamento. Está bom?

[00:42] Precisamos dizer através de CompilerOptions onde os arquivos compilados serão gerados. Estamos dizendo que qualquer arquivo modificado na pasta 'app" vai ser gerado na pasta "dist" com a extensão "js" compilado transformado para JavaScript.

[01:01] Também colocamos noEmitOnError para dizer que se o arquivo TypeScript que eu estou salvando tiver um problema de compilação, que não faz sentido gerar um arquivo "js" para ele, então nada vai acontecer, nenhum arquivo "js" vai ser gerado. Está bom?

[01:17] Uma outra coisa que vimos no projeto é que quando eu vou lá no meu "package.json" criamos dois scripts, o compile e o watch. O compile quando executo vai compilar, vai transformar meus arquivos "ts" para JavaScript na devida pasta, mas só que ficar rodando esse comando toda hora não é muito legal, por isso criamos o watch.

[01:44] Esse watch vai ficar escutando, qualquer modificação dentro da pasta "dist" e se você modificou qualquer arquivo "ts" lá dentro automaticamente ele vai gerar o arquivo dentro da pasta "js". Tudo maravilhoso, mas vimos que precisamos compartilhar a pasta "dist" no navegador utilizando o nosso Live Server e, ao mesmo tempo, precisamos reexecutar o compilador do TypeScript.

[02:10] Como conseguimos isso? Executando o comando start, porque esse comando start vai executar o npn run watch combinado com o do server. É tudo maravilhoso, vamos para o abraço, porque qualquer alteração feita no meu arquivo "ts" o compilador TypeScript vai escutar, vai gravar na pasta "dist".

[02:30] E o Live Server qualquer modificação na pasta "dist" feita, ele vai fazer o refresh no navegador, então conseguimos alterando em um único lugar todo nosso pipeline vai ser executado e o resultado será refletido no navegador.

[02:46] Nós vimos também que na hora que declaramos arquivos TypeScript, como o nome diz, o TypeScript vai gerar um monte de checagem no nosso código e uma das checagens que nós vimos é que se eu omito um parâmetro no construtor da minha classe ele vai me indicar que tem um erro, então, eu como programador, vou lembrar lá e vou verificar qual parâmetro que eu tenho que passar.

[03:07] Vimos que ele também me permite ter o auto complete mais apurado, isso significa que quando eu clico .data eu consigo ter esse auto complete das propriedades da minha classe.

[03:22] Outra coisa que vimos é que o TypeScript me permite, por exemplo, se eu cometo uma gafe na hora de digitar, como ele sabe que estou utilizando tipo "negociação", ele sabe que você tem que escrever o correto, que não existe, não tem ninguém declarado aqui para nós.

[03:39] Também nós vimos que ao definir o nosso modelo, que podemos abdicar do modo privado do JavaScript usando a sintaxe tralha e nós substituímos pela instrução private do TypeScript, isso significa que se eu estou utilizando o meu auto complete, a própria IDE é integrada com o TypeScript, não vai sugerir os atributos aqui como private, adotado como private.

[04:08] Se eu removo esse private e salvo, volto lá, ele vai aparecer aqui porque não disse que eu quero esconder ele do desenvolvedor, que eu quero tornar ele privado.

[04:21] Se você está curioso para saber qual é o tipo dele, quando você não coloca nada é mesma coisa que public, tem um bônus aqui. Se você clicar agora aqui, todo mundo que é public aparece aqui para você, só que o TypeScript me permiti omitir o tipo public e inferir que é public quando você não define nenhum modificador de acesso.

[04:49] Temos tudo no lugar no entendimento embrionário, básico de TypeScript para podermos agora construir nossa aplicação e, à medida que vamos construindo nossa aplicação, vamos vendo qual recurso do TypeScript pode ajudar a escrever um código lindo, sem defeito, garantido que vai rodar sem problema durante a runtime. Está bom? Vejo vocês no próximo capítulo.

CONTROLLERDE NEGOCIAÇÃO


[00:00] Agora que temos o entendimento inicial do TypeScript, a dinâmica de forças entre compilador, arquivo TS e temos nossa modelagem de negociação vamos começar a construir nossa aplicação.

[00:13] Eu vou dar o npm run start para ele rodar o compilador em tempo real o TypeScript e abrir a nossa aplicação. O que eu quero fazer? Nossa aplicação, quando eu clicar em incluir ela tem que conseguir pegar a data que o usuário incluiu, a quantidade, o valor e criar uma instância de negociação. Por enquanto só vamos criar essa instância e exibir no console do navegador.

[00:41] Será que o TypeScript nos ajuda, atrapalha, como é essa história toda? Vamos ver como fazemos isso tudo usando a linguagem em TypeScript. Primeira coisa que eu vou fazer aqui eu vou usar o conceito controller.

[00:55] Um controller vai uma classe, vamos criar uma instância dessa classe, ela que vai controlar a interação desse form e quando eu clicar em incluir é essa negociação controller que vamos criar que vai pegar os dados do formulário e criar o meu modelo.

[01:15] Esse controller vai ser a ponte entre as interações do usuário na minha página e a criação de modelos, ele vai ser o meio de campo. Ele vai ter uma dependência de elementos de UAI, a minha data, a minha quantidade, o meu valor, e vai fazer a comunicação disso com o nosso modelo.

[01:35] Vou voltar para o meu projeto, dentro de "App" eu tenho a pasta "controllers > New File" e vou criar um novo arquivo que eu vou chamar de negociacao-controller.ts. Cuidado, não é “js” é “ts”. Eu tenho a minha negociação controller aqui. Vou começar porque vou querer usar isso em algum outro lugar da minha aplicação, por isso vou começar com: export class Negociacaocontroller {.

[02:09] O que essa negociação controller vai ter? Eu preciso, assim que ela for instanciada, ela tem uma referência para o input da data, da quantidade e do valor. De começo o que vou colocar é o seguinte: vou criar private inputData; private inputQuantidade; private inputValor; }.

[02:54] No momento quando o meu construtor for inicializado dessa classe, olha o que vou fazer: constructor() { this.inputData =. Precisamos ter um conhecimento de JavaScript, lá na pasta "dist" vou abrir o html, sabemos que o campo data tem o id data, que o campo valor tem o id valor e que o campo quantidade tem o id quantidade.

[03:23] Preciso usar o document querySelector para pegar essa função e colocar aqui no meu código. Vou fazer: document.querySelector, isso aqui é JavaScript puro não tem nada de TypeScript, vou pegar o elemento que tem data, this.inputQuantidade vai ser document.querySelector (‘#quantidade), para pegar o input da quantidade.

[03:53] E this.inputValor = document.querySelector (‘#valor’). Então: constructor() { this.inputData = document.querySelector('#data'); this.inputQuantidade = document.querySelector('#quantidade'); this.inputValor = document.querySelector('#valor'); }.

[04:05] Isso significa que no momento que eu criar a instância de negociação controller, se estou criando uma instância de negociação controller o constructor vai ser executado. Aí vou ao DOM e pego esses elementos do dom atribuo aqui nessas propriedades do construtor da minha classe.

[04:25] Porque quando eu chamar o método adiciona, adiciona(), esse método tem que primeiro fazer: console.log(this.inputData);. Só para sabermos se realmente pegamos essas funções quando eu chamar.

[04:54] Na verdade, sabemos que eu tenho que criar uma negociação pegando a data, a quantidade e valor. Inicialmente vou dar um console.log para vermos como as coisas se encaixam. adiciona() { console.log(this.inputData); console.log(this.inputQuantidade); console.log(this.inputValor); }.

[05:06] Por aqui não tem mistério nenhum, a única novidade olhando aqui de TypeScript para nós é o modificador private aqui. Quando a minha negociação controller for criada ela vai guardar o inputValor, inputQuantidade e o inputData em uma propriedade da classe e toda vez que eu chamar o método adiciona ele vai imprimir no console esses elementos do dom que eu peguei.

INTEGRAÇÃO COM FORMULÁRIO


[00:00] Vou lá em "app.ts" e quem eu quero importar é o negociação-controller. Só que vou mostrar uma coisa legal para vocês aqui, um atalho. Porém, temos que tomar cuidado, olha o que vou fazer: vou dizer queconst controller = new NegociacaoController();. Quando eu escrevo, o Visual Studio Code já vai me dá um atalho para importar o negociação-controller.

[00:33] Vou clicar aqui, quando eu faço isso, ele fez o auto complete para mim. import { NegociacaoController } from './controllers/negociacao-controller'; const controller = new NegociacaoController();

[00:41] Atenção redobrada, fez o auto complete para mim e fez o import automático. Maravilhoso. Mas você precisa colocar js no final, senão isso não vai funcionar. import { NegociacaoController } from './controllers/negociacao-controller.js'; Se você já viu código escrito em Angular, Reach ou Vue JS, eles não precisam colocar o js porque o sistema de build deles por debaixo dos panos vai lá e coloca esse js para eles.

[01:09] Para nós precisamos colocar, por isso cuidado com esse auto import para que você não esqueça de colocar o js no final, senão o seu código não vai funcionar. É um atalho bem legal, vamos tentar usá-lo.

[01:27] Criei meu controller. A sacada é que todas as vezes que você submete o formulário, olha aqui eu tenho o form e aqui eu tenho o botão, button primary.

[01:39] Toda vez que você submeter esse formulário eu quero chamar o método adiciona do meu controller, para isso eu preciso pegar esse formulário que está na minha página e colocar no meu código. Vou fazer: const form = document.querySelector('.form');, peguei o form e sabemos que se é um form vou colocar: form.addEventListener.

[02:18] Olha como o TypeScript é legal, eu fiz o querySelector e ele está me dizendo que está retornando algo do tipo element, que ganhou um tipo implícito element e por ser isso entende que todo element tem o addEventListener.

[02:38] Se você submeter form, submit, vou pegar o evento, vou passar o evento, pego o evento e vou chamar controller.adiciona();. form.addEventListener('submit', event => { controller.adiciona(); }).

[02:59] Vamos recapitular, quando a minha aplicação inicia vai criar uma instância de negociação controller, ela tem dentro dela uma referência por input da quantidade, por input da data, input do valor. E eu peguei o form e disse que toda vez que você submeter esse form eu vou chamar o adiciona.

[03:22] Sabemos que se eu fizer isso com a minha página ela vai recarregar. Vou mostrar para vocês um problema que temos que resolver aqui básico do JavaScript, mas ele é a ponta do iceberg para mostrar uma coisa bem legal aqui em TypeScript. Salvei, não tive erro de compilação. Quando eu chamar agora o adiciona, vamos voltar ao navegador, abrir o console. Vou escolher uma data qualquer, uma quantidade, um valor e vou clicar em incluir.

[04:33] Quando eu olho no console, você vai ver que eu vou clicar em incluir, a minha página está fazendo refresh. Ela está até exibindo no console, mas está fazendo refresh e não pode porque sabemos que todo formulário quando você submete, ele faz um refresh da página.

[04:52] Como a nossa aplicação tenta copiar uma single page application, que é uma página que não recarrega durante o seu uso, eu preciso cancelar o evento padrão do formulário que é submissão, vou fazer: event.preventDefault();.

[05:14] O TypeScript já inferiu que form é do tipo event, é como se eu já tivesse colocado o event aqui, mas como é parâmetro tem que está entre parênteses. O TypeScript automaticamente, como ele sabe que esse daqui é uma Arrow Function para o addEventListener, ele automaticamente infere que form é um event do tipo submit e vai fazer o auto complete para mim.

[05:43] Vou salvar, vou voltar para o navegador, vou limpar e digitar qualquer coisa, clico em incluir. Está tudo bonito, tudo maravilhoso.

[05:58] Conseguimos ver aqui tranquilamente que os inputs que colocamos no incluir quando eu clico exibindo foram obtidos pelo dom e a minha página não faz refresh. Agora vamos construir a nossa negociação com a informação que o usuário colocou para nós.